% function Peak_Finding(correlation_map)  
% 
% Description:
%        
% This function generates a contour map of the correlation map 
%
% Fields: correlation_map, low_threshold, high_threshold 
%   
% Initial conditions:
% 
% correlation_map must be generated from the
% correlation_line function, low and high threshold must be either decimal
% or integer values between 0 and 1. 
%   
% Final conditions: None 
%

function Peak_Finding(correlation_map)
 
    user_input_low = 0.5;
    user_input_high = 1.0;
   
    C = contour(correlation_map);

    % find the indices of peaks within this region 
    peak_region_idx = find(C > user_input_low & C < user_input_high); 
 
    % extract peaks and their x and y coordinates
    peaks_and_coord = C(peak_region_idx(1):end);

    % interpolate data for best point possible 
    parsed_contour_data = Parse_Contour_Data(peaks_and_coord);
    
    % group and determine outliers. 
    [outliers, grouped_array_data] = Find_Max_Fun(parsed_contour_data);
    %count intensities and plot them 
    count_intensity(outliers, grouped_array_data);
  
end
% function parsed_data = Peak_Contour_Data(peak_coord, contour_matrix)
% 
% Description:     
%  
%   This function extracts contour intensities and coordinates from the
%   contour matrix. 
% 
%
% Fields: peak_coord
%   
% Initial conditions: 
%  
% peak_coord must be a coordinate-intensity matrix generated by the contour
% function   
%
% Final conditions: returns a properly parsed contour cell array of structs
%

function parsed_data = Parse_Contour_Data(peak_coord)
    
    % variables
    intensity_data = struct();

    %indices
    idx = 2;
    struct_idx = 1;
    peak_intensity_idx = 1;
    
    while idx < numel(peak_coord)
  
        peak_intensity = peak_coord(1,peak_intensity_idx);
        peak_init_height = peak_coord(1,idx);
        cord_counter = idx+1:2:(2*peak_init_height)+idx;
    
        x_cord = peak_coord(cord_counter);
        y_cord = peak_coord(cord_counter+1);
     
        %average the sum
        ave_x = sum(x_cord) / numel(x_cord);
        ave_y = sum(y_cord) / numel(y_cord);
        
        %store inside struct
        intensity_data(struct_idx).region_intensity = peak_intensity;
        intensity_data(struct_idx).average_coordinate_x = ave_x;
        intensity_data(struct_idx).average_coordinate_y = ave_y;
        intensity_data(struct_idx).x_coord = x_cord;
        intensity_data(struct_idx).y_coord = y_cord;
      
        struct_idx = struct_idx + 1;
        peak_intensity_idx = (2*peak_init_height)+idx + 1;
        idx = (2*peak_init_height)+idx + 2;
    
    end
   
    %find minimum
    parsed_data  = intensity_data;    

end

% function [outliers, intensity_minimum_array] = Find_Max_Fun(intensity_struct_data)
%    
% Description:
%  
% This function takes in a structure of intensities and their coordinates,
% and group them into meaningful groups. 
% 
% Fields: intensity_struct_data
%   
% Initial conditions: 
%
% intensity_struct_data must be a structure that contains the line's
% 
% intensities and their average x and y coordinates. 
%     
%
% Final conditions:  returns the outlier data found and a cell array of
% strutures with the intensities found

function [outliers, intensity_array] = Find_Max_Fun(intensity_struct_data)
    
    out_lier_data = 0;   
    size_struct_data = numel(intensity_struct_data);
    [min_intensity_group, new_intensity_struct_data] = Group_calc(intensity_struct_data, size_struct_data);
    
    if numel(new_intensity_struct_data) > 0
         
        [intensity_group_additional, new_intensity_struct_data] = Group_calc(new_intensity_struct_data, size_struct_data);
          
        min_intensity_group = [min_intensity_group intensity_group_additional];
        
        if numel(new_intensity_struct_data) > 0
            disp('Outliers')
            new_intensity_struct_data(:).region_intensity
            out_lier_data = numel(new_intensity_struct_data);
            
     
        end        
        
    end
        
    min_intensity_group(all(cellfun(@isempty,min_intensity_group),2), : ) = [];
    outliers = new_intensity_struct_data;
    intensity_array = min_intensity_group;
   
  
end
% function [min_intensity_data, new_intensity_struct_data] = Group_calc(intensity_data_struct, size_struct_data)
% 
% Description:
% 
% Groups like intensities with average x and y coordinates differences
% smaller than 3. 
% 
% Fields: intensity_data_struct, size_struct_data
%   
% Initial conditions: 
%
% intensity_data_struct must be a struct with pre-parsed intensity data.
% size_struct_data must be an integer that represents the size of the
% intensity_data_struct
%     
% Final conditions: 
%
%  returns min_intensity_data, which is a cell array that represents the grouped intensities
%  and new_intensity_struct_data, which is a cell array that represents outlier data that does
%  not belong to any groups.     
%

function [min_intensity_data, new_intensity_struct_data] = Group_calc(intensity_data_struct, size_struct_data)
                                                                  
    min_intensity = min([intensity_data_struct(:).region_intensity]);
    min_intensity_location_array = find([intensity_data_struct(:).region_intensity]...
                                                         == min_intensity); 

    peak_diff= 3;
  
    min_intensity_group_array = cell(size_struct_data, numel(min_intensity_location_array));                                                              
    num_max_intensity_struct = numel(intensity_data_struct);
    
    for idx = 1:numel(min_intensity_location_array)
   
        min_intensity_group_array{1,idx} = intensity_data_struct(min_intensity_location_array(idx));

        for idx_2 = num_max_intensity_struct : -1: numel(min_intensity_location_array)+1

            peak_threshold_min_x = min_intensity_group_array{1,idx}.average_coordinate_x(1);
            peak_threshold_min_y = min_intensity_group_array{1,idx}.average_coordinate_y(1);

            if (abs(intensity_data_struct(idx_2).average_coordinate_x(1) - peak_threshold_min_x)) ...
                    < peak_diff

                if (abs(intensity_data_struct(idx_2).average_coordinate_y(1) - peak_threshold_min_y)) ...
                        < peak_diff
                    emptyCells = cellfun(@isempty,min_intensity_group_array(:,idx));

                    empty_cell_idx = find(emptyCells == 1);

                    min_intensity_group_array{empty_cell_idx(end),idx} = intensity_data_struct(idx_2);

                    intensity_data_struct(idx_2) = [];
                    num_max_intensity_struct = num_max_intensity_struct - 1;


                else

                    continue;

                end

            end

        end

    end
    
    intensity_data_struct(min_intensity_location_array) = [];
    new_intensity_struct_data = intensity_data_struct;
    
    min_intensity_data = min_intensity_group_array;
    
end

% function count_intensity(out_lier_data, intensity_array)
% 
% Description:
%        
% This function counts the number of intensities found and plot them onto
% the contour map
%
% Fields: out_lier_data, intensity_array
%   
% Initial conditions: 
%
% out_lier_data must be an integer, and intensity_array must be an array of
% integers that represents the grouped intensities.
%     
% Final conditions: None  


function count_intensity(out_lier,intensity_array)

     sz_intensity_array = size(intensity_array);
     sz_outlier = size(out_lier);
   
     num_peaks = sz_intensity_array(2)+ numel(out_lier);
     num_outliers = sz_outlier(2);
          
     fprintf('There are %d peaks between your 0.6 and 1\n', num_peaks);
    
     % go through each column and locate the intensities
     for idx = 1:sz_intensity_array(2)
        
         hold on;
         non_empty_idx = find(~cellfun(@isempty, intensity_array(:,idx)));
         
         % if there is only one element in the column, then that means that
         % the only element is the peak
         if numel(non_empty_idx) == 1
       
             x_cord = intensity_array{non_empty_idx,idx}.average_coordinate_x;
             y_cord =intensity_array{non_empty_idx,idx}.average_coordinate_y;
       
             plot(x_cord,y_cord,'+','LineWidth',2,'MarkerSize',10,'MarkerEdgeColor','b','MarkerFaceColor',[0.5,0.5,0.5]);
             % Label the points with the corresponding 'x' value
             labelstr = sprintf(' %.2f,%.2f ', x_cord, y_cord);
             text(x_cord,y_cord, labelstr, 'VerticalAlignment', 'bottom');
             
         else
         
             % if there are more elements, then the max intensity is at the
             % last position of the column
             x_cord = intensity_array{non_empty_idx(end), idx}.average_coordinate_x;
             y_cord = intensity_array{non_empty_idx(end), idx}.average_coordinate_y;
             
             hold on
             plot(x_cord,y_cord,'+','LineWidth',2,'MarkerSize',10,'MarkerEdgeColor','b','MarkerFaceColor',[0.5,0.5,0.5]);
             % Label the points with the corresponding 'x' value
             labelstr = sprintf(' %.2f,%.2f ', x_cord, y_cord);
             text(x_cord,y_cord, labelstr, 'VerticalAlignment', 'bottom');

        
         end

     end
     
     % plotting outliers into the matrix
     for idx = 1:num_outliers
        
         for idx_2 = 1:sz_outlier(1)
             
             hold on;
             x_cord = out_lier(idx_2, idx).average_coordinate_x;
             y_cord = out_lier(idx_2, idx).average_coordinate_y;
             
             plot(x_cord,y_cord,'+','LineWidth',2,'MarkerSize',10,'MarkerEdgeColor','b','MarkerFaceColor',[0.5,0.5,0.5]);
             % Label the points with the corresponding 'x' value
             labelstr = sprintf(' %.2f,%.2f ', x_cord, y_cord);
             text(x_cord,y_cord, labelstr, 'VerticalAlignment', 'bottom');
             
         end
    
     end     
     hold off
     
  
end

